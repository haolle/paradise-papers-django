==============================================
How to query the Neo4j database with Neomodel.
==============================================

Intro.
======

I assume that you know how to create a Django project and how to init and setup a Django app inside
this project. If you don’t have a clue of what I said, I recommend to come back after reading the
Django intro tutorial and start again from part one of this tutorial:
https://docs.djangoproject.com/en/1.11/intro/

At this point of the tutorial, you should have already created and setup the paradise_paper_search
Django project and the fetch_api Django app(:doc:`Part 1 <part01>`). You learned how to integrate
the Neomodel OGM into the Django project(:doc:`Part 2 <part02>`). Also, at :doc:`Part 3 <part03>`
you learned the way a Neo4j Graph Database is modeled using Neomodel and ended with a serie of
python class definitions that represent the nodes, properties and relationships of the
Paradise Paper Graph Database(PPGDB).

Current project structure::

    paradise_papers_search/
    ├── paradise_papers_search/
    │   └── +
    ├── fetch_api/
    │   ├── __init__.py
    │   ├── admin.py
    │   ├── apps.py
    │   ├── migrations/
    │   │   └── __init__.py
    │   ├── models/
    │   │   ├── __init__.py
    │   │   ├── address.py
    │   │   ├── entity.py
    │   │   ├── intermediary.py
    │   │   ├── officer.py
    │   │   └── other.py
    │   ├── tests.py
    │   ├── urls.py
    │   └── views.py
    └── manage.py

Now, how you actually query a graph database inside your Django project or apps?

Using your models
===================================

Using your models is pretty standard. You usually just import the ones you need and use them, for
example, in your Django views. Before we get to that, we need to learn the Neomodel Query API. This
API will allow us to express queries to the database without having to write them in plain Cypher.

We will learn to query using the Paradise Paper models we did before.
To do that we will first use an instance of the python interpreter.

The project python interpreter:
---------------------------------------

Let's open the python interpreter through our Django project ``manage.py`` which will import our
project settings(remember you set the DATABASE_URL in there, this is needed to connect to the db).
Also, it will try to use ipython or bpython if available.

First let’s start opening the console, if necessary.

Then make sure you are at the ``paradise_papers_search`` root directory
where you created the Django project(where the ``manage.py`` module is).

Run the command::

        python manage.py shell


With the python interpreter at hand, we can import our models and start to use them as soon as we
execute the following python import commands::

    from fetch_api.models import Entity
    from fetch_api.models import Intermediary
    from fetch_api.models import Officer
    from fetch_api.models import Address
    from fetch_api.models import Other

Each of the models we just imported maps to a specific structure of a node label, property keys and
relationship types in the PPGDB. Now we are actually ready to start exploring the
Paradise Paper Graph Database through the Neomodel Query API.

..  todo::
    Put screenshot image of the console here.

Neomodel Query API
==================
Each of your models has some properties and methods(inherited from StructureNode or DjangoNode)
that help us to express queries to the Neo4j database.

NodeSet and Nodes Neomodel objects
--------------------------------------------------------
A *NodeSet* object represents a set of nodes matching common query parameters or filters.

A *Node* object is an instance of one of our models. That means we can access all the properties
and methods defined on the model class. Each instance represents a single node in the database.

The ``<Model>.nodes`` class property of each model store a NodeSet object. Each time we access
this ``.nodes`` property we get a brand new nodeset object, which means we get nodeset without any
filters applied. Initially, before applying any filters, this noseset represents all the nodes
mapped under a model(nodes labeled with the same class name). For instance, ``Entity.nodes``
contains all the nodes with the label Entity on the database.

Later we will see how we can apply filters in order to match a specific subset of nodes.

Length of a NodeSet
-------------------
If we wanted to count all the Entity nodes that are stored in the database, we just call
the ``len`` python function over the ``Entity.nodes`` nodeset.

Example::

    len(Entity.nodes)

When we call ``len(Entity.nodes)``, Neomodel will generate a cypher query that counts
all the nodes with the label ``Entity``. Then that query is executed in the Neo4j database and
we get back the count. The cypher query string that is generated by Neomodel behind the scene is::

    MATCH (n:Entity) RETURN COUNT(n)

.. note::
    We are not retrieving all the nodes from the database and then count them. The actual counting
    is done by the Neo4j database engine which is faster.

Another example, to get count of all the nodes that exist in the PPGDB database::

    len(Entity.nodes) \
    + len(Officer.nodes) \
    + len(Intermediary.nodes) \
    + len(Address.nodes) \
    + len(Other.nodes)

..  todo::
    Put screenshot image of the console here.

If nodeset is filtered, only nodes that fulfill the filters will be counted.

Fetching nodes
----------------
In order to retrieve the nodes, read their properties and relationships, an actual cypher query need
to be executed by Neomodel. This is handled completely by Neomodel and we just need to use its
query API.

A call to the NodeSet method ``.all()``, would return all the nodes of a nodeset; nevertheless
this would result in an expensive query. The reason is that Neomodel will actually try to
retrieve all the nodes at once. It is recommended to use ``.all()`` when the nodeset is small.
We can reduce the size by filtering the nodeset as will see in the later.

It is better to fetch the nodes in batches from a nodeset. The NodeSet objects support the same
operators for indexing and slicing just like the normal python lists.

To get the first element of the ``Entity.nodes`` nodeset, we can reference its index::

    Entity.nodes[0]

To get a subset of nodes, we can use the python slice syntax. This is convenient for writing code
that retrieve the nodes in batches. For example to get the first 10 nodes in a list::

    Entity.nodes[0:10]

.. note::
    Neomodel will generate and execute cypher query only to retrieve the nodes we are asking for.
    So we are not actually retrieving all the nodes at once from the database. An example of a
    cypher query string generated by new model would be
    ``MATCH (n:Entity) RETURN n SKIP 10 LIMIT 10``

Finding nodes
-------------
If we know exactly what node we are looking for, for instance we have the node_id or the exact name
property value, we can use the ``.get()`` or ``.get_or_none()`` nodeset methods. The difference is
that if no match, the first one will raise a DoesNotExist exception and the second will return
`None`.

To get the node which node_id is ``160380`` in a given nodeset::

    Entity.nodes.get_or_none(node_id=160380)
    Entity.nodes.get(node_id=160380)

.. warning::
    These methods will raise MultipleNodesReturned exception if the property value
    used to get the node is not unique.

Filtering nodes
---------------
It is very probable that we want to get a subset of nodes that fulfill a specified condition.
For example, getting all the Entity nodes which name property contains a specific word.

In order to filter nodes in a nodeset, we use the NodeSet method ``.filter```.
The filter method borrows the same django filter format with double underscore prefixed operators.

To get Entity nodes which name property has the word "financial", we use the operator `contains`::

    Entity.nodes.filter(name__contains='financial')

The above statement will return a filtered nodeset, in order to actually retrieve the data see
the Fetching Nodes section. For more prefixed operators refer to this page:
http://neomodel.readthedocs.io/en/latest/queries.html#node-sets-and-filtering

Creating some utils to search the PPGDB
=======================================
The purpose of this tutorial is to show you how we can use Neomodel with Django. In order to do
that we will build an app that will search the Paradise Paper Graph Database.
With what we have learned so far is enough for our purpose.

We will create some function utils that will help us search the PPGDB. Later, we will find ourselves
importing and using these helper functions to fetch data from the DB in our Django views.

To start coding, first let's create a new python module under our ``fetch_api/`` directory.
Name the file as `utils.py`

Now, as we will want to query the Neo4j database, we will import our models.
Put the below import statements at the start of the `utils.py``::

    from .models import Entity
    from .models import Intermediary
    from .models import Officer
    from .models import Address
    from .models import Other

In order to easily access each of the model classes programmatically, let's create a key-value map.
The key will be the model class name and the value will be the model class itself::

    MODEL_ENTITIES = {
        'Entity': Entity,
        'Address': Address,
        'Intermediary': Intermediary,
        'Officer': Officer,
        'Other': Other
    }

Filter Nodes Helper
-------------------

We will create a function that receive a model class and some filter parameters like *name, country
jurisdiction and source_id*. Then this functin will return a filtered nodeset contaning only the
model nodes that pass our filters.

Let's add this helper function to the ``utils.py``, with the name ``filter_nodes``::

    def filter_nodes(node_type, search_text, country, jurisdiction, source_id):
        node_set = node_type.nodes

        # On Address nodes we want to check the search_text against the address property
        # For any other we check against the name property
        if node_type.__name__ == 'Address':
            node_set.filter(address__icontains=search_text)
        else:
            node_set.filter(name__icontains=search_text)

        # Only entities store jurisdiction info
        if node_type.__name__ == 'Entity':
            node_set.filter(jurisdiction__icontains=jurisdiction)

        node_set.filter(countries__icontains=country)
        node_set.filter(sourceID__icontains=source_id)

        return node_set

Count Nodes Helper
------------------

We will create a function that return the length of the nodeset returned by the ``filter_nodes`` 
helper we created before. It will receive a dictionary of filters.

Here a representation of the required dictionary keys::

    {
        'node_type': '',
        'name': '',
        'country': '',
        'jurisdiction': '',
        'sourceID': ''
    }

Let's add this helper function to the ``utils.py``, with the name ``count_nodes``::

    def count_nodes(count_info):
        count = {}
        node_type               = count_info['node_type']
        search_word             = count_info['name']
        country                 = count_info['country']
        jurisdiction            = count_info['jurisdiction']
        data_source             = count_info['sourceID']
        node_set                = filter_nodes(MODEL_ENTITIES[node_type], search_word, country, jurisdiction, data_source)
        count['count']          = len(node_set)

        return count

Fetch Nodes Helper
------------------

We will create a function that returns a subset of nodes filtered by the ``filter_nodes`` helper that we created previously. It will receive a dictionary of filters.

Here a representation of the required dictionary keys::

    {
        'node_type': '',
        'name': '',
        'country': '',
        'jurisdiction': '',
        'sourceID': ''
        'limit': 10,
        'page': 1
    }

The ``limit`` and ``page`` filters are necesary to calculate the ``start`` and ``end`` values that
we will use to get a subset of nodes from a nodeset. 
Just like we learned in the Fetching Nodes section, we will return the nodes in batches using
slice python syntax on the nodeset.

Let's add this helper function to the ``utils.py``, with the name ``fetch_nodes``::

    def fetch_nodes(fetch_info):
        node_type       = fetch_info['node_type']
        search_word     = fetch_info['name']
        country         = fetch_info['country']
        limit           = fetch_info['limit']
        start           = ((fetch_info['page'] - 1) * limit)
        end             = start + limit
        jurisdiction    = fetch_info['jurisdiction']
        data_source     = fetch_info['sourceID']
        node_set        = filter_nodes(MODEL_ENTITIES[node_type], search_word, country, jurisdiction, data_source)
        fetched_nodes   = node_set[start:end]

        return fetched_nodes

Fetch Node Details Helper
-------------------------

We will create a function that return a single node. It will receive a dictionary of filters with
the ``node_type`` and the ``node_id``.

Here a representation of the required dictionary keys::

    {
        'node_type': '',
        'node_id': ''
    }

Let's add this helper function to the ``utils.py``, with the name ``fetch_node_details``::

    def fetch_node_details(node_info):
        node_type       = node_info['node_type']
        node_id         = node_info['node_id']
        node            = MODEL_ENTITIES[node_type].nodes.get(node_id=node_id)
        node_details    = node

        return node_details



...
